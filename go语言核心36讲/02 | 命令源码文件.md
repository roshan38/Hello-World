# 02 | 命令源码文件
**源码文件分为三种，即：命令源码文件、库源码文件和测试源码文件，他们有着不同的用途和编写规则。**

**命令源码文件构建生成可执行文件，位置在命令执行目录。安装后生成可执行文件（.exe），生成位置在命令执行目录。**

**库源码文件构建后只生产临时文件（检查和验证），在操作系统的临时目录下。安装后生产归档文件（.a），生成位置在当前工作区的pkg子目录。**

**测试源码文件：**

功能测试源码文件TestXXX（t *tesing.T）

性能（基准）测试源码文件BenchmarkXxx（b *tesing.B）

实例（样本）测试源码文件ExampleXxx（签名没有硬性要求），测试函数期望输出，放在函数末尾，用注释行表示，例如：**//Output:xxx**


本节深入学习命令源码文件
## 命令源码文件的用途是什么，怎样编写它？

命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建和安装，生成与之对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。

**如果一个源码文件生命属于main包，并且包含一个无参数声明的main函数，那么它就是命令源码文件**
例:

package main

import "fmt"

func main() {
	fmt.Println("Hello, world!")
}

## 知识精讲
### 1. 命令源码文件怎样接收参数
go语言标准库中有一个代码包专门用于接收和解析**命令参数**。这个代码包的名字叫**flag**
**flag.Parse()用于解析命令参数，并把它们的值付给相应变量。**
**对该函数的调用必须在所有命令参数储存载体的声明和设置之后，并且在读取任何命令参数值之前进行。**
例：

package main

import (
	"flag" 
	"fmt"
)

var name string

func init() {
	flag.StringVar(&name,"name","everyone","The greeting object")//地址、参数名称、默认值、help
}

func main() {
	flag.Parse()// 需在此处添加代码。[3]
	fmt.Printf("Hello, %s!\n", name)
}

**疑问：func init()是什么时候被调用的？**
### 2. 怎样在运行命令源码文件的时候传入参数，又怎样查看参数的使用说明
$ go run demog.go -name="Robert"
$ go run demog.go --help
### 3. 怎样自定义命令源码文件的参数使用说明(基本看不懂，都记下来了，翻看)
最简单的一种方式就是对变量flag.Usage重新赋值。//注意，对flag.Usage的赋值必须在调用flag.Parse函数之前
在上面例子的main函数开始处加入

flag.Usage = func() {
 fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
 flag.PrintDefaults()
}

当运行$ go run demo3.go --help

后，就会看到

Usage of question:
 -name string
    The greeting object. (default "everyone")
exit status 2

**再深入一层，我们在调用flag包中的一些函数的时候，实际上是在调用flag.CommandLine变量的对用方法。**

**flag.CommandLine相当于默认情况下的命令参数容器。所以，通过对flagCommandLine重新赋值，我们可以更深层次地定制当前命令源码文件的参数使用说明。**

在最初的代码开始处添加如下代码

flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
flag.CommandLine.Usage = func() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	flag.PrintDefaults()
}

与上例输出一致

**再进一步，创建一个私有的命令参数容器**

var cmdLine =flag.NewFlagSet("question",flag.ExitOnError)

然后，我们把对flag.StringVar的调用替换为对cmdLine.StringVar调用，再把flag.Parse()替换为cmdLine.Parse(os.Args[1:])。

**其中的os.Args[1:]指的就是我们给定的那些命令参数**。这样做就完全脱离了flag.CommandLine。

## 思考题
### 1、默认情况下，我们可以让命令源码文件接收那些类型的参数值？
int(int|int64|uint|uint64)

float(float|float64)

string

bool

duration//时间

var//自定义
### 2、我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎么做？
关键就是使用flag.var()，关键点在于需要实现flag包的Value接口。
