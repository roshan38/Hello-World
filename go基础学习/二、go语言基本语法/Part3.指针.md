# 第三部分 指针
把指针单独拿出来以示尊重

go语言中为程序员提供了指针，但是**不能使用指针运算**，如：

var s string

&s+1//是非法的

指针的概念在go语言中被拆分为两个核心概念：

**类型指针**也就是C语言的指针，指向某个类型的数据。（存某个数据的地址）

**切片**由指向起始元素的原始指针、元素数量和容量组成

因此go语言的指针类型变量拥有指针的高效访问，但又不会发生指针偏移，从而避免非法修改关键性数据问题。//*原因是不能直接改地址的值*

切片比原始指针具备更强大的特性，更为安全。切片发生越界时，运行时会爆出宕机，并打出堆栈，而原始指针只会崩溃。

## 指针的声明
ptr := &v    // v的类型为T

var ptr \*T = v//这两个声明是一样的

其中 v 代表被取地址的变量，被取地址的 v 使用 ptr 变量进行接收，ptr 的类型就为\*T，称做 T 的指针类型。\*代表指针。

指针的其他内容跟C语言差不多。

## 示例：使用指针变量获取命令行的输入信息
例：

package main

// 导入系统包
import (
    "flag"
    "fmt"
)

// 定义命令行参数
var mode = flag.String("mode", "", "process mode")

func main() {

    // 解析命令行参数
    flag.Parse()

    // 输出命令行参数
    fmt.Println(*mode)
}

flag.Parse()这个函数是解析命令行参数（通俗地说就是把命令行的参数代入吧？）
## 创建指针的另一种方法————new()函数
str := new(string)

\*str ="ninja"


fmt.Println(\*str)
//Output:ninja
